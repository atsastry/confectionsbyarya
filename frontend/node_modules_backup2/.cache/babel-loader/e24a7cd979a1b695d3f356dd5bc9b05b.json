{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nvar _objectSpread = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _asyncToGenerator = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nvar util_1 = require(\"util\");\nvar bson_1 = require(\"./bson\");\nvar metrics_1 = require(\"./cmap/metrics\");\nvar shared_1 = require(\"./cmap/wire_protocol/shared\");\nvar constants_1 = require(\"./constants\");\nvar error_1 = require(\"./error\");\nvar mongo_types_1 = require(\"./mongo_types\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar run_command_1 = require(\"./operations/run_command\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar common_1 = require(\"./sdam/common\");\nvar transactions_1 = require(\"./transactions\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\nvar minWireVersionForShardedTransactions = 8;\n/** @internal */\nvar kServerSession = Symbol('serverSession');\n/** @internal */\nvar kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nvar kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nvar kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nvar kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nvar ClientSession = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(ClientSession, _mongo_types_1$TypedE);\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  function ClientSession(client, sessionPool, options, clientOptions) {\n    var _this;\n    _classCallCheck(this, ClientSession);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientSession).call(this));\n    /** @internal */\n    _this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = options ?? {};\n    if (options.snapshot === true) {\n      _this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    _this.client = client;\n    _this.sessionPool = sessionPool;\n    _this.hasEnded = false;\n    _this.clientOptions = clientOptions;\n    _this.explicit = !!options.explicit;\n    _this[kServerSession] = _this.explicit ? _this.sessionPool.acquire() : null;\n    _this[kTxnNumberIncrement] = 0;\n    var defaultCausalConsistencyValue = _this.explicit && options.snapshot !== true;\n    _this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n    _this.clusterTime = options.initialClusterTime;\n    _this.operationTime = undefined;\n    _this.owner = options.owner;\n    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    _this.transaction = new transactions_1.Transaction();\n    return _this;\n  }\n  /** The server id associated with this session */\n  _createClass(ClientSession, [{\n    key: \"pin\",\n    /** @internal */value: function pin(conn) {\n      if (this[kPinnedConnection]) {\n        throw TypeError('Cannot pin multiple connections to the same session');\n      }\n      this[kPinnedConnection] = conn;\n      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    } /** @internal */\n  }, {\n    key: \"unpin\",\n    value: function unpin(options) {\n      if (this.loadBalanced) {\n        return maybeClearPinnedConnection(this, options);\n      }\n      this.transaction.unpinServer();\n    }\n  }, {\n    key: \"endSession\",\n    /**\n     * Ends this session on the server\n     *\n     * @param options - Optional settings. Currently reserved for future use\n     */\n    value: function () {\n      var _endSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var serverSession;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                if (!this.inTransaction()) {\n                  _context.next = 4;\n                  break;\n                }\n                _context.next = 4;\n                return this.abortTransaction();\n              case 4:\n                if (!this.hasEnded) {\n                  serverSession = this[kServerSession];\n                  if (serverSession != null) {\n                    // release the server session back to the pool\n                    this.sessionPool.release(serverSession);\n                    // Make sure a new serverSession never makes it onto this ClientSession\n                    Object.defineProperty(this, kServerSession, {\n                      value: ServerSession.clone(serverSession),\n                      writable: false\n                    });\n                  }\n                  // mark the session as ended, and emit a signal\n                  this.hasEnded = true;\n                  this.emit('ended', this);\n                }\n                _context.next = 9;\n                break;\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](0);\n              case 9:\n                _context.prev = 9;\n                maybeClearPinnedConnection(this, _objectSpread({\n                  force: true\n                }, options));\n                return _context.finish(9);\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 7, 9, 12]]);\n      }));\n      function endSession(_x) {\n        return _endSession.apply(this, arguments);\n      }\n      return endSession;\n    }()\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n  }, {\n    key: \"advanceOperationTime\",\n    value: function advanceOperationTime(operationTime) {\n      if (this.operationTime == null) {\n        this.operationTime = operationTime;\n        return;\n      }\n      if (operationTime.greaterThan(this.operationTime)) {\n        this.operationTime = operationTime;\n      }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n  }, {\n    key: \"advanceClusterTime\",\n    value: function advanceClusterTime(clusterTime) {\n      if (!clusterTime || typeof clusterTime !== 'object') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n      }\n      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n        throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n      }\n      if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && clusterTime.signature.keyId?._bsontype !== 'Long' // apparently we decode the key to number?\n      ) {\n        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n      }\n      (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(session) {\n      if (!(session instanceof ClientSession)) {\n        return false;\n      }\n      if (this.id == null || session.id == null) {\n        return false;\n      }\n      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     *\n     * @privateRemarks\n     * This helper increments a value stored on the client session that will be\n     * added to the serverSession's txnNumber upon applying it to a command.\n     * This is because the serverSession is lazily acquired after a connection is obtained\n     */\n  }, {\n    key: \"incrementTransactionNumber\",\n    value: function incrementTransactionNumber() {\n      this[kTxnNumberIncrement] += 1;\n    } /** @returns whether this session is currently in a transaction or not */\n  }, {\n    key: \"inTransaction\",\n    value: function inTransaction() {\n      return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction(options) {\n      if (this[kSnapshotEnabled]) {\n        throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n      }\n      if (this.inTransaction()) {\n        throw new error_1.MongoTransactionError('Transaction already in progress');\n      }\n      if (this.isPinned && this.transaction.isCommitted) {\n        this.unpin();\n      }\n      var topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n        throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n      }\n      // increment txnNumber\n      this.incrementTransactionNumber();\n      // create transaction state\n      this.transaction = new transactions_1.Transaction({\n        readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,\n        writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,\n        readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,\n        maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n      });\n      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    /**\n     * Commits the currently active transaction in this session.\n     */\n  }, {\n    key: \"commitTransaction\",\n    value: function () {\n      var _commitTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", endTransactionAsync(this, 'commitTransaction'));\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function commitTransaction() {\n        return _commitTransaction.apply(this, arguments);\n      }\n      return commitTransaction;\n    }()\n    /**\n     * Aborts the currently active transaction in this session.\n     */\n  }, {\n    key: \"abortTransaction\",\n    value: function () {\n      var _abortTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", endTransactionAsync(this, 'abortTransaction'));\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function abortTransaction() {\n        return _abortTransaction.apply(this, arguments);\n      }\n      return abortTransaction;\n    }()\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n  }, {\n    key: \"toBSON\",\n    value: function toBSON() {\n      throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n     *\n     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n     *\n     * @remarks\n     * This function:\n     * - If all operations successfully complete and the `commitTransaction` operation is successful, then this function will return the result of the provided function.\n     * - If the transaction is unable to complete or an error is thrown from within the provided function, then this function will throw an error.\n     *   - If the transaction is manually aborted within the provided function it will not throw.\n     * - May be called multiple times if the driver needs to attempt to retry the operations.\n     *\n     * Checkout a descriptive example here:\n     * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n     *\n     * @param fn - callback to run within a transaction\n     * @param options - optional settings for the transaction\n     * @returns A raw command response or undefined\n     */\n  }, {\n    key: \"withTransaction\",\n    value: function () {\n      var _withTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fn, options) {\n        var startTime;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                startTime = (0, utils_1.now)();\n                return _context4.abrupt(\"return\", attemptTransaction(this, startTime, fn, options));\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function withTransaction(_x2, _x3) {\n        return _withTransaction.apply(this, arguments);\n      }\n      return withTransaction;\n    }()\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this[kServerSession]?.id;\n    }\n  }, {\n    key: \"serverSession\",\n    get: function get() {\n      var serverSession = this[kServerSession];\n      if (serverSession == null) {\n        if (this.explicit) {\n          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n        }\n        if (this.hasEnded) {\n          throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n        }\n        serverSession = this.sessionPool.acquire();\n        this[kServerSession] = serverSession;\n      }\n      return serverSession;\n    } /** Whether or not this session is configured for snapshot reads */\n  }, {\n    key: \"snapshotEnabled\",\n    get: function get() {\n      return this[kSnapshotEnabled];\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n    } /** @internal */\n  }, {\n    key: \"pinnedConnection\",\n    get: function get() {\n      return this[kPinnedConnection];\n    }\n  }, {\n    key: \"isPinned\",\n    get: function get() {\n      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n  }]);\n  return ClientSession;\n}(mongo_types_1.TypedEventEmitter);\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nvar MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nvar NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  var isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  var conn = session[kPinnedConnection];\n  var error = options?.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  var topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    var servers = Array.from(topology.s.servers.values());\n    var loadBalancer = servers[0];\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n    session[kPinnedConnection] = undefined;\n  }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nfunction attemptTransactionCommit(session, startTime, fn, result, options) {\n  return session.commitTransaction().then(function () {\n    return result;\n  }, function (err) {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, result, options);\n      }\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nvar USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  session.startTransaction(options);\n  var promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(function () {\n      return null;\n    });\n    return Promise.reject(new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise'));\n  }\n  return promise.then(function (result) {\n    if (userExplicitlyEndedTransaction(session)) {\n      return result;\n    }\n    return attemptTransactionCommit(session, startTime, fn, result, options);\n  }, function (err) {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n      throw err;\n    }\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(function () {\n        return maybeRetryOrThrow(err);\n      });\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nvar endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  var txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n  // construct and send the command\n  var command = _defineProperty({}, commandName, 1);\n  // apply a writeConcern if specified\n  var writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeoutMS: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    write_concern_1.WriteConcern.apply(command, writeConcern);\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(error) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      }\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof error_1.MongoError) {\n      if ((0, error_1.isRetryableWriteError)(error) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n          // per txns spec, must unpin session in this case\n          session.unpin({\n            error: error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error: error\n        });\n      }\n    }\n    callback(error);\n  }\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  // send the command\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n    session: session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), function (error) {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (error instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(error)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n        session: session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n    commandHandler(error);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nvar ServerSession = /*#__PURE__*/function () {\n  /** @internal */\n  function ServerSession() {\n    _classCallCheck(this, ServerSession);\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  _createClass(ServerSession, [{\n    key: \"hasTimedOut\",\n    value: function hasTimedOut(sessionTimeoutMinutes) {\n      // Take the difference of the lastUse timestamp and now, which will result in a value in\n      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n      var idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n      return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n    /**\n     * @internal\n     * Cloning meant to keep a readable reference to the server session data\n     * after ClientSession has ended\n     */\n  }], [{\n    key: \"clone\",\n    value: function clone(serverSession) {\n      var arrayBuffer = new ArrayBuffer(16);\n      var idBytes = Buffer.from(arrayBuffer);\n      idBytes.set(serverSession.id.id.buffer);\n      var id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n      // Manual prototype construction to avoid modifying the constructor of this class\n      return Object.setPrototypeOf({\n        id: {\n          id: id\n        },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      }, ServerSession.prototype);\n    }\n  }]);\n  return ServerSession;\n}();\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nvar ServerSessionPool = /*#__PURE__*/function () {\n  function ServerSessionPool(client) {\n    _classCallCheck(this, ServerSessionPool);\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  _createClass(ServerSessionPool, [{\n    key: \"acquire\",\n    value: function acquire() {\n      var sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n      var session = null;\n      // Try to obtain from session pool\n      while (this.sessions.length > 0) {\n        var potentialSession = this.sessions.shift();\n        if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n          session = potentialSession;\n          break;\n        }\n      }\n      // If nothing valid came from the pool make a new one\n      if (session == null) {\n        session = new ServerSession();\n      }\n      return session;\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n  }, {\n    key: \"release\",\n    value: function release(session) {\n      var sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n      if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n        this.sessions.unshift(session);\n      }\n      if (!sessionTimeoutMinutes) {\n        return;\n      }\n      this.sessions.prune(function (session) {\n        return session.hasTimedOut(sessionTimeoutMinutes);\n      });\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        if (session.isDirty) {\n          return;\n        }\n        // otherwise, readd this session to the session pool\n        this.sessions.unshift(session);\n      }\n    }\n  }]);\n  return ServerSessionPool;\n}();\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  var serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  var inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  var isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    var atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":null,"metadata":{},"sourceType":"script"}
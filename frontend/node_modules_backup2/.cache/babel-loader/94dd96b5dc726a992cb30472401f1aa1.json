{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _objectSpread = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _asyncToGenerator = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nvar bson_1 = require(\"./bson\");\nvar ordered_1 = require(\"./bulk/ordered\");\nvar unordered_1 = require(\"./bulk/unordered\");\nvar change_stream_1 = require(\"./change_stream\");\nvar aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nvar find_cursor_1 = require(\"./cursor/find_cursor\");\nvar list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nvar list_search_indexes_cursor_1 = require(\"./cursor/list_search_indexes_cursor\");\nvar error_1 = require(\"./error\");\nvar bulk_write_1 = require(\"./operations/bulk_write\");\nvar count_1 = require(\"./operations/count\");\nvar count_documents_1 = require(\"./operations/count_documents\");\nvar delete_1 = require(\"./operations/delete\");\nvar distinct_1 = require(\"./operations/distinct\");\nvar drop_1 = require(\"./operations/drop\");\nvar estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar find_and_modify_1 = require(\"./operations/find_and_modify\");\nvar indexes_1 = require(\"./operations/indexes\");\nvar insert_1 = require(\"./operations/insert\");\nvar is_capped_1 = require(\"./operations/is_capped\");\nvar options_operation_1 = require(\"./operations/options_operation\");\nvar rename_1 = require(\"./operations/rename\");\nvar create_1 = require(\"./operations/search_indexes/create\");\nvar drop_2 = require(\"./operations/search_indexes/drop\");\nvar update_1 = require(\"./operations/search_indexes/update\");\nvar update_2 = require(\"./operations/update\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\nvar Collection = /*#__PURE__*/function () {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  function Collection(db, name, options) {\n    _classCallCheck(this, Collection);\n    // Internal state\n    this.s = {\n      db: db,\n      options: options,\n      namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.client = db.client;\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n  _createClass(Collection, [{\n    key: \"insertOne\",\n    /**\n     * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param doc - The document to insert\n     * @param options - Optional settings for the command\n     */\n    value: function () {\n      var _insertOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(doc, options) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function insertOne(_x, _x2) {\n        return _insertOne.apply(this, arguments);\n      }\n      return insertOne;\n    }()\n    /**\n     * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"insertMany\",\n    value: function () {\n      var _insertMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(docs, options) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? {\n                  ordered: true\n                }))));\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function insertMany(_x3, _x4) {\n        return _insertMany.apply(this, arguments);\n      }\n      return insertMany;\n    }()\n    /**\n     * Perform a bulkWrite operation without a fluent API\n     *\n     * Legal operation types are\n     * - `insertOne`\n     * - `replaceOne`\n     * - `updateOne`\n     * - `updateMany`\n     * - `deleteOne`\n     * - `deleteMany`\n     *\n     * If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @param operations - Bulk operations to perform\n     * @param options - Optional settings for the command\n     * @throws MongoDriverError if operations is not an array\n     */\n  }, {\n    key: \"bulkWrite\",\n    value: function () {\n      var _bulkWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(operations, options) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (Array.isArray(operations)) {\n                  _context3.next = 2;\n                  break;\n                }\n                throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n              case 2:\n                return _context3.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? {\n                  ordered: true\n                }))));\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function bulkWrite(_x5, _x6) {\n        return _bulkWrite.apply(this, arguments);\n      }\n      return bulkWrite;\n    }()\n    /**\n     * Update a single document in a collection\n     *\n     * @param filter - The filter used to select the document to update\n     * @param update - The update operations to be applied to the document\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"updateOne\",\n    value: function () {\n      var _updateOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function updateOne(_x7, _x8, _x9) {\n        return _updateOne.apply(this, arguments);\n      }\n      return updateOne;\n    }()\n    /**\n     * Replace a document in a collection with another document\n     *\n     * @param filter - The filter used to select the document to replace\n     * @param replacement - The Document that replaces the matching document\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"replaceOne\",\n    value: function () {\n      var _replaceOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(filter, replacement, options) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function replaceOne(_x10, _x11, _x12) {\n        return _replaceOne.apply(this, arguments);\n      }\n      return replaceOne;\n    }()\n    /**\n     * Update multiple documents in a collection\n     *\n     * @param filter - The filter used to select the documents to update\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"updateMany\",\n    value: function () {\n      var _updateMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function updateMany(_x13, _x14, _x15) {\n        return _updateMany.apply(this, arguments);\n      }\n      return updateMany;\n    }()\n    /**\n     * Delete a document from a collection\n     *\n     * @param filter - The filter used to select the document to remove\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"deleteOne\",\n    value: function () {\n      var _deleteOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var filter,\n          options,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                filter = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                return _context7.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function deleteOne() {\n        return _deleteOne.apply(this, arguments);\n      }\n      return deleteOne;\n    }()\n    /**\n     * Delete multiple documents from a collection\n     *\n     * @param filter - The filter used to select the documents to remove\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"deleteMany\",\n    value: function () {\n      var _deleteMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var filter,\n          options,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                filter = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                return _context8.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function deleteMany() {\n        return _deleteMany.apply(this, arguments);\n      }\n      return deleteMany;\n    }()\n    /**\n     * Rename the collection.\n     *\n     * @remarks\n     * This operation does not inherit options from the Db or MongoClient.\n     *\n     * @param newName - New name of of the collection.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"rename\",\n    value: function () {\n      var _rename = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(newName, options) {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, _objectSpread({}, options, {\n                  readPreference: read_preference_1.ReadPreference.PRIMARY\n                }))));\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function rename(_x16, _x17) {\n        return _rename.apply(this, arguments);\n      }\n      return rename;\n    }()\n    /**\n     * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"drop\",\n    value: function () {\n      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options)));\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function drop(_x18) {\n        return _drop.apply(this, arguments);\n      }\n      return drop;\n    }()\n  }, {\n    key: \"findOne\",\n    value: function () {\n      var _findOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var filter,\n          options,\n          cursor,\n          res,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                filter = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n                options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n                cursor = this.find(filter, options).limit(-1).batchSize(1);\n                _context11.next = 5;\n                return cursor.next();\n              case 5:\n                res = _context11.sent;\n                _context11.next = 8;\n                return cursor.close();\n              case 8:\n                return _context11.abrupt(\"return\", res);\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n      function findOne() {\n        return _findOne.apply(this, arguments);\n      }\n      return findOne;\n    }()\n  }, {\n    key: \"find\",\n    value: function find() {\n      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Returns the options of the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"options\",\n    value: function () {\n      var _options2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_options) {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, _options))));\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n      function options(_x19) {\n        return _options2.apply(this, arguments);\n      }\n      return options;\n    }()\n    /**\n     * Returns if the collection is a capped collection\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"isCapped\",\n    value: function () {\n      var _isCapped = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                return _context13.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n      function isCapped(_x20) {\n        return _isCapped.apply(this, arguments);\n      }\n      return isCapped;\n    }()\n    /**\n     * Creates an index on the db and collection collection.\n     *\n     * @param indexSpec - The field name or index specification to create an index for\n     * @param options - Optional settings for the command\n     *\n     * @example\n     * ```ts\n     * const collection = client.db('foo').collection('bar');\n     *\n     * await collection.createIndex({ a: 1, b: -1 });\n     *\n     * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n     * await collection.createIndex([ [c, 1], [d, -1] ]);\n     *\n     * // Equivalent to { e: 1 }\n     * await collection.createIndex('e');\n     *\n     * // Equivalent to { f: 1, g: 1 }\n     * await collection.createIndex(['f', 'g'])\n     *\n     * // Equivalent to { h: 1, i: -1 }\n     * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n     *\n     * // Equivalent to { j: 1, k: -1, l: 2d }\n     * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n     * ```\n     */\n  }, {\n    key: \"createIndex\",\n    value: function () {\n      var _createIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(indexSpec, options) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n      function createIndex(_x21, _x22) {\n        return _createIndex.apply(this, arguments);\n      }\n      return createIndex;\n    }()\n    /**\n     * Creates multiple indexes in the collection, this method is only supported for\n     * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n     * error.\n     *\n     * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n     * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\n     *\n     * @param indexSpecs - An array of index specifications to be created\n     * @param options - Optional settings for the command\n     *\n     * @example\n     * ```ts\n     * const collection = client.db('foo').collection('bar');\n     * await collection.createIndexes([\n     *   // Simple index on field fizz\n     *   {\n     *     key: { fizz: 1 },\n     *   }\n     *   // wildcard index\n     *   {\n     *     key: { '$**': 1 }\n     *   },\n     *   // named index on darmok and jalad\n     *   {\n     *     key: { darmok: 1, jalad: -1 }\n     *     name: 'tanagra'\n     *   }\n     * ]);\n     * ```\n     */\n  }, {\n    key: \"createIndexes\",\n    value: function () {\n      var _createIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(indexSpecs, options) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, _objectSpread({}, options, {\n                  maxTimeMS: undefined\n                })))));\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n      function createIndexes(_x23, _x24) {\n        return _createIndexes.apply(this, arguments);\n      }\n      return createIndexes;\n    }()\n    /**\n     * Drops an index from this collection.\n     *\n     * @param indexName - Name of the index to drop.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"dropIndex\",\n    value: function () {\n      var _dropIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(indexName, options) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                return _context16.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, _objectSpread({}, (0, utils_1.resolveOptions)(this, options), {\n                  readPreference: read_preference_1.ReadPreference.primary\n                }))));\n              case 1:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n      function dropIndex(_x25, _x26) {\n        return _dropIndex.apply(this, arguments);\n      }\n      return dropIndex;\n    }()\n    /**\n     * Drops all indexes from this collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"dropIndexes\",\n    value: function () {\n      var _dropIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(options) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _context17.next = 3;\n                return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, '*', (0, utils_1.resolveOptions)(this, options)));\n              case 3:\n                return _context17.abrupt(\"return\", true);\n              case 6:\n                _context17.prev = 6;\n                _context17.t0 = _context17[\"catch\"](0);\n                return _context17.abrupt(\"return\", false);\n              case 9:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this, [[0, 6]]);\n      }));\n      function dropIndexes(_x27) {\n        return _dropIndexes.apply(this, arguments);\n      }\n      return dropIndexes;\n    }()\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"listIndexes\",\n    value: function listIndexes(options) {\n      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Checks if one or more indexes exist on the collection, fails on first non-existing index\n     *\n     * @param indexes - One or more index names to check.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexExists\",\n    value: function () {\n      var _indexExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(indexes, options) {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                return _context18.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n      function indexExists(_x28, _x29) {\n        return _indexExists.apply(this, arguments);\n      }\n      return indexExists;\n    }()\n    /**\n     * Retrieves this collections index info.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexInformation\",\n    value: function () {\n      var _indexInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(options) {\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                return _context19.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n      function indexInformation(_x30) {\n        return _indexInformation.apply(this, arguments);\n      }\n      return indexInformation;\n    }()\n    /**\n     * Gets an estimate of the count of documents in a collection using collection metadata.\n     * This will always run a count command on all server versions.\n     *\n     * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n     * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n     * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n     * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n     * encountering errors.\n     *\n     * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"estimatedDocumentCount\",\n    value: function () {\n      var _estimatedDocumentCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(options) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                return _context20.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n      function estimatedDocumentCount(_x31) {\n        return _estimatedDocumentCount.apply(this, arguments);\n      }\n      return estimatedDocumentCount;\n    }()\n    /**\n     * Gets the number of documents matching the filter.\n     * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n     * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n     * the following query operators must be replaced:\n     *\n     * | Operator | Replacement |\n     * | -------- | ----------- |\n     * | `$where`   | [`$expr`][1] |\n     * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n     * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n     *\n     * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n     * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n     * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n     * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n     *\n     * @param filter - The filter for the count\n     * @param options - Optional settings for the command\n     *\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n     * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n     */\n  }, {\n    key: \"countDocuments\",\n    value: function () {\n      var _countDocuments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var filter,\n          options,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                filter = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : {};\n                options = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};\n                return _context21.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n      function countDocuments() {\n        return _countDocuments.apply(this, arguments);\n      }\n      return countDocuments;\n    }()\n  }, {\n    key: \"distinct\",\n    value: function () {\n      var _distinct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(key) {\n        var filter,\n          options,\n          _args22 = arguments;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                filter = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {};\n                options = _args22.length > 2 && _args22[2] !== undefined ? _args22[2] : {};\n                return _context22.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 3:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n      function distinct(_x32) {\n        return _distinct.apply(this, arguments);\n      }\n      return distinct;\n    }()\n    /**\n     * Retrieve all the indexes on the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"indexes\",\n    value: function () {\n      var _indexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(options) {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                return _context23.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n      function indexes(_x33) {\n        return _indexes.apply(this, arguments);\n      }\n      return indexes;\n    }()\n  }, {\n    key: \"findOneAndDelete\",\n    value: function () {\n      var _findOneAndDelete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(filter, options) {\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                return _context24.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n      function findOneAndDelete(_x34, _x35) {\n        return _findOneAndDelete.apply(this, arguments);\n      }\n      return findOneAndDelete;\n    }()\n  }, {\n    key: \"findOneAndReplace\",\n    value: function () {\n      var _findOneAndReplace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(filter, replacement, options) {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                return _context25.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n      function findOneAndReplace(_x36, _x37, _x38) {\n        return _findOneAndReplace.apply(this, arguments);\n      }\n      return findOneAndReplace;\n    }()\n  }, {\n    key: \"findOneAndUpdate\",\n    value: function () {\n      var _findOneAndUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(filter, update, options) {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                return _context26.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options))));\n              case 1:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n      function findOneAndUpdate(_x39, _x40, _x41) {\n        return _findOneAndUpdate.apply(this, arguments);\n      }\n      return findOneAndUpdate;\n    }()\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"aggregate\",\n    value: function aggregate() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (!Array.isArray(pipeline)) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n      }\n      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct use cases:\n     * - The first is to override the schema that may be defined for this specific collection\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     * @example\n     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n     * ```ts\n     * collection.watch<{ _id: number }>()\n     *   .on('change', change => console.log(change._id.toFixed(4)));\n     * ```\n     *\n     * @example\n     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n     * No need start from scratch on the ChangeStreamInsertDocument type!\n     * By using an intersection we can save time and ensure defaults remain the same type!\n     * ```ts\n     * collection\n     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n     *     { $addFields: { comment: 'big changes' } },\n     *     { $match: { operationType: 'insert' } }\n     *   ])\n     *   .on('change', change => {\n     *     change.comment.startsWith('big');\n     *     change.operationType === 'insert';\n     *     // No need to narrow in code because the generics did that for us!\n     *     expectType<Schema>(change.fullDocument);\n     *   });\n     * ```\n     *\n     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TLocal - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeUnorderedBulkOp\",\n    value: function initializeUnorderedBulkOp(options) {\n      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeOrderedBulkOp\",\n    value: function initializeOrderedBulkOp(options) {\n      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * An estimated count of matching documents in the db to a filter.\n     *\n     * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n     * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n     * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n     *\n     * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n     *\n     * @param filter - The filter for the count.\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"count\",\n    value: function () {\n      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var filter,\n          options,\n          _args27 = arguments;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                filter = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : {};\n                options = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : {};\n                return _context27.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options))));\n              case 3:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n      function count() {\n        return _count.apply(this, arguments);\n      }\n      return count;\n    }()\n  }, {\n    key: \"listSearchIndexes\",\n    value: function listSearchIndexes(indexNameOrOptions, options) {\n      options = typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;\n      var indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === 'object' ? null : indexNameOrOptions;\n      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);\n    }\n    /**\n     * Creates a single search index for the collection.\n     *\n     * @param description - The index description for the new search index.\n     * @returns A promise that resolves to the name of the new search index.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"createSearchIndex\",\n    value: function () {\n      var _createSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(description) {\n        var _yield$this$createSea, _yield$this$createSea2, index;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.createSearchIndexes([description]);\n              case 2:\n                _yield$this$createSea = _context28.sent;\n                _yield$this$createSea2 = _slicedToArray(_yield$this$createSea, 1);\n                index = _yield$this$createSea2[0];\n                return _context28.abrupt(\"return\", index);\n              case 6:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n      function createSearchIndex(_x42) {\n        return _createSearchIndex.apply(this, arguments);\n      }\n      return createSearchIndex;\n    }()\n    /**\n     * Creates multiple search indexes for the current collection.\n     *\n     * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\n     * @returns A promise that resolves to an array of the newly created search index names.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     * @returns\n     */\n  }, {\n    key: \"createSearchIndexes\",\n    value: function () {\n      var _createSearchIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(descriptions) {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                return _context29.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions)));\n              case 1:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n      function createSearchIndexes(_x43) {\n        return _createSearchIndexes.apply(this, arguments);\n      }\n      return createSearchIndexes;\n    }()\n    /**\n     * Deletes a search index by index name.\n     *\n     * @param name - The name of the search index to be deleted.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"dropSearchIndex\",\n    value: function () {\n      var _dropSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(name) {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                return _context30.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name)));\n              case 1:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n      function dropSearchIndex(_x44) {\n        return _dropSearchIndex.apply(this, arguments);\n      }\n      return dropSearchIndex;\n    }()\n    /**\n     * Updates a search index by replacing the existing index definition with the provided definition.\n     *\n     * @param name - The name of the search index to update.\n     * @param definition - The new search index definition.\n     *\n     * @remarks Only available when used against a 7.0+ Atlas cluster.\n     */\n  }, {\n    key: \"updateSearchIndex\",\n    value: function () {\n      var _updateSearchIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(name, definition) {\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                return _context31.abrupt(\"return\", (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition)));\n              case 1:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n      function updateSearchIndex(_x45, _x46) {\n        return _updateSearchIndex.apply(this, arguments);\n      }\n      return updateSearchIndex;\n    }()\n  }, {\n    key: \"dbName\",\n    get: function get() {\n      return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n  }, {\n    key: \"collectionName\",\n    get: function get() {\n      return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n  }, {\n    key: \"namespace\",\n    get: function get() {\n      return this.fullNamespace.toString();\n    }\n    /**\n     *  @internal\n     *\n     * The `MongoDBNamespace` for the collection.\n     */\n  }, {\n    key: \"fullNamespace\",\n    get: function get() {\n      return this.s.namespace;\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      if (this.s.readConcern == null) {\n        return this.s.db.readConcern;\n      }\n      return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      if (this.s.readPreference == null) {\n        return this.s.db.readPreference;\n      }\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      if (this.s.writeConcern == null) {\n        return this.s.db.writeConcern;\n      }\n      return this.s.writeConcern;\n    } /** The current index hint for the collection */\n  }, {\n    key: \"hint\",\n    get: function get() {\n      return this.s.collectionHint;\n    },\n    set: function set(v) {\n      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n    }\n  }]);\n  return Collection;\n}();\nexports.Collection = Collection;","map":null,"metadata":{},"sourceType":"script"}
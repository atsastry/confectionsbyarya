{"ast":null,"code":"\"use strict\";\n\nvar _wrapNativeSuper = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\nvar _asyncToGenerator = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _possibleConstructorReturn = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _getPrototypeOf = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _toArray = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\nvar _classCallCheck = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _objectSpread = require(\"/Users/aryasastry/bootcamp-project-2022/milestone3/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DOCUMENT_DB_CHECK = exports.TimeoutController = exports.request = exports.matchesParentDomain = exports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.maybeCallback = exports.makeCounter = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.hostMatchesWildcards = exports.ByteUtils = void 0;\nexports.isHostMatch = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = void 0;\nvar crypto = require(\"crypto\");\nvar http = require(\"http\");\nvar timers_1 = require(\"timers\");\nvar url = require(\"url\");\nvar url_1 = require(\"url\");\nvar bson_1 = require(\"./bson\");\nvar constants_1 = require(\"./cmap/wire_protocol/constants\");\nvar constants_2 = require(\"./constants\");\nvar error_1 = require(\"./error\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar common_1 = require(\"./sdam/common\");\nvar write_concern_1 = require(\"./write_concern\");\nexports.ByteUtils = {\n  toLocalBufferType: function toLocalBufferType(buffer) {\n    return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  },\n  equals: function equals(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);\n  },\n  compare: function compare(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);\n  },\n  toBase64: function toBase64(uint8array) {\n    return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');\n  }\n};\n/**\n * Determines if a connection's address matches a user provided list\n * of domain wildcards.\n */\nfunction hostMatchesWildcards(host, wildcards) {\n  var _iterator = _createForOfIteratorHelper(wildcards),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var wildcard = _step.value;\n      if (host === wildcard || wildcard.startsWith('*.') && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith('*/') && host?.endsWith(wildcard.substring(2, wildcard.length))) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return false;\n}\nexports.hostMatchesWildcards = hostMatchesWildcards;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n  var finalHint = undefined;\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n  return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\nvar TO_STRING = function TO_STRING(object) {\n  return Object.prototype.toString.call(object);\n};\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction mergeOptions(target, source) {\n  return _objectSpread({}, target, source);\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n  var filterOptions = {};\n  for (var name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n  // Filtered options\n  return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n  return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(value) {\n  return !!value && typeof value.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  var capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(\"Current topology does not support collation\");\n    }\n  }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  var readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider && provider.client.topology) {\n    return provider.client.topology;\n  }\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/** @internal */\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nvar MongoDBNamespace = /*#__PURE__*/function () {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  function MongoDBNamespace(db, collection) {\n    _classCallCheck(this, MongoDBNamespace);\n    this.db = db;\n    this.collection = collection;\n    this.collection = collection === '' ? undefined : collection;\n  }\n  _createClass(MongoDBNamespace, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.collection ? \"\".concat(this.db, \".\").concat(this.collection) : this.db;\n    }\n  }, {\n    key: \"withCollection\",\n    value: function withCollection(collection) {\n      return new MongoDBCollectionNamespace(this.db, collection);\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(namespace) {\n      if (typeof namespace !== 'string' || namespace === '') {\n        // TODO(NODE-3483): Replace with MongoNamespaceError\n        throw new error_1.MongoRuntimeError(\"Cannot parse namespace from \\\"\".concat(namespace, \"\\\"\"));\n      }\n      var _namespace$split = namespace.split('.'),\n        _namespace$split2 = _toArray(_namespace$split),\n        db = _namespace$split2[0],\n        collectionParts = _namespace$split2.slice(1);\n      var collection = collectionParts.join('.');\n      return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n    }\n  }]);\n  return MongoDBNamespace;\n}();\nexports.MongoDBNamespace = MongoDBNamespace;\n/**\n * @public\n *\n * A class representing a collection's namespace.  This class enforces (through Typescript) that\n * the `collection` portion of the namespace is defined and should only be\n * used in scenarios where this can be guaranteed.\n */\nvar MongoDBCollectionNamespace = /*#__PURE__*/function (_MongoDBNamespace) {\n  _inherits(MongoDBCollectionNamespace, _MongoDBNamespace);\n  function MongoDBCollectionNamespace(db, collection) {\n    var _this;\n    _classCallCheck(this, MongoDBCollectionNamespace);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoDBCollectionNamespace).call(this, db, collection));\n    _this.collection = collection;\n    return _this;\n  }\n  _createClass(MongoDBCollectionNamespace, null, [{\n    key: \"fromString\",\n    value: function fromString(namespace) {\n      return _get(_getPrototypeOf(MongoDBCollectionNamespace), \"fromString\", this).call(this, namespace);\n    }\n  }]);\n  return MongoDBCollectionNamespace;\n}(MongoDBNamespace);\nexports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;\n/** @internal */\nfunction makeCounter() {\n  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var count, newCount;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            count = seed;\n          case 1:\n            if (!true) {\n              _context.next = 8;\n              break;\n            }\n            newCount = count;\n            count += 1;\n            _context.next = 6;\n            return newCount;\n          case 6:\n            _context.next = 1;\n            break;\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })();\n}\nexports.makeCounter = makeCounter;\nfunction maybeCallback(promiseFn, callback) {\n  var promise = promiseFn();\n  if (callback == null) {\n    return promise;\n  }\n  promise.then(function (result) {\n    return callback(undefined, result);\n  }, function (error) {\n    return callback(error);\n  });\n  return;\n}\nexports.maybeCallback = maybeCallback;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n  var result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      var lastHello = topologyOrServer.lastHello();\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n  return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  var idx = 0;\n  var awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n  return arr.length === arr2.length && arr.every(function (elt, idx) {\n    return elt === arr2[idx];\n  });\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n  return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    var legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(\"illegal state transition from [\".concat(target.s.state, \"] => [\").concat(newState, \"], allowed: [\").concat(legalStates, \"]\"));\n    }\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\nexports.makeStateMachine = makeStateMachine;\n/** @internal */\nfunction now() {\n  var hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n  var elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    var _iterator2 = _createForOfIteratorHelper(doc),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var document = _step2.value;\n        if (hasAtomicOperators(document)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return false;\n  }\n  var keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n  var result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  var session = options?.session;\n  if (!session?.inTransaction()) {\n    var readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n    var writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n  var readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n  return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  var _iterator3 = _createForOfIteratorHelper(subset),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var elem = _step3.value;\n      if (!set.has(elem)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return true;\n}\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\nfunction setDifference(setA, setB) {\n  var difference = new Set(setA);\n  var _iterator4 = _createForOfIteratorHelper(setB),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var elem = _step4.value;\n      difference.delete(elem);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return difference;\n}\nexports.setDifference = setDifference;\nvar HAS_OWN = function HAS_OWN(object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop);\n};\nfunction isRecord(value) {\n  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (!isObject(value)) {\n    return false;\n  }\n  var ctor = value.constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n    // Check to see if some method exists from the Object exists\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n  if (requiredKeys) {\n    var keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n  return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(function (item) {\n      return deepCopy(item);\n    });\n  } else if (isRecord(value)) {\n    var res = {};\n    for (var key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n  var ctor = value.constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value);\n      case 'set':\n        return new Set(value);\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n  return value;\n}\nexports.deepCopy = deepCopy;\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\nvar List = /*#__PURE__*/function () {\n  _createClass(List, [{\n    key: \"length\",\n    get: function get() {\n      return this.count;\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return 'List';\n    }\n  }]);\n  function List() {\n    _classCallCheck(this, List);\n    this.count = 0;\n    // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    };\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n  _createClass(List, [{\n    key: \"toArray\",\n    value: function toArray() {\n      return Array.from(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"head <=> \".concat(this.toArray().join(' <=> '), \" <=> head\");\n    }\n  }, {\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {\n      var _iterator5, _step5, node;\n      return _regeneratorRuntime().wrap(function value$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator5 = _createForOfIteratorHelper(this.nodes());\n              _context2.prev = 1;\n              _iterator5.s();\n            case 3:\n              if ((_step5 = _iterator5.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n              node = _step5.value;\n              _context2.next = 7;\n              return node.value;\n            case 7:\n              _context2.next = 3;\n              break;\n            case 9:\n              _context2.next = 14;\n              break;\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n              _iterator5.e(_context2.t0);\n            case 14:\n              _context2.prev = 14;\n              _iterator5.f();\n              return _context2.finish(14);\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, value, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"nodes\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function nodes() {\n      var ptr, _ptr, next;\n      return _regeneratorRuntime().wrap(function nodes$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              ptr = this.head.next;\n            case 1:\n              if (!(ptr !== this.head)) {\n                _context3.next = 8;\n                break;\n              }\n              // Save next before yielding so that we make removing within iteration safe\n              _ptr = ptr, next = _ptr.next;\n              _context3.next = 5;\n              return ptr;\n            case 5:\n              ptr = next;\n              _context3.next = 1;\n              break;\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, nodes, this);\n    }) /** Insert at end of list */\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      this.count += 1;\n      var newNode = {\n        next: this.head,\n        prev: this.head.prev,\n        value: value\n      };\n      this.head.prev.next = newNode;\n      this.head.prev = newNode;\n    } /** Inserts every item inside an iterable instead of the iterable itself */\n  }, {\n    key: \"pushMany\",\n    value: function pushMany(iterable) {\n      var _iterator6 = _createForOfIteratorHelper(iterable),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _value = _step6.value;\n          this.push(_value);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    } /** Insert at front of list */\n  }, {\n    key: \"unshift\",\n    value: function unshift(value) {\n      this.count += 1;\n      var newNode = {\n        next: this.head.next,\n        prev: this.head,\n        value: value\n      };\n      this.head.next.prev = newNode;\n      this.head.next = newNode;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      if (node === this.head || this.length === 0) {\n        return null;\n      }\n      this.count -= 1;\n      var prevNode = node.prev;\n      var nextNode = node.next;\n      prevNode.next = nextNode;\n      nextNode.prev = prevNode;\n      return node.value;\n    } /** Removes the first node at the front of the list */\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return this.remove(this.head.next);\n    } /** Removes the last node at the end of the list */\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.remove(this.head.prev);\n    } /** Iterates through the list and removes nodes where filter returns true */\n  }, {\n    key: \"prune\",\n    value: function prune(filter) {\n      var _iterator7 = _createForOfIteratorHelper(this.nodes()),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var node = _step7.value;\n          if (filter(node.value)) {\n            this.remove(node);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.count = 0;\n      this.head.next = this.head;\n      this.head.prev = this.head;\n    } /** Returns the first item in the list, does not remove */\n  }, {\n    key: \"first\",\n    value: function first() {\n      // If the list is empty, value will be the head's null\n      return this.head.next.value;\n    } /** Returns the last item in the list, does not remove */\n  }, {\n    key: \"last\",\n    value: function last() {\n      // If the list is empty, value will be the head's null\n      return this.head.prev.value;\n    }\n  }]);\n  return List;\n}();\nexports.List = List;\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nvar BufferPool = /*#__PURE__*/function () {\n  function BufferPool() {\n    _classCallCheck(this, BufferPool);\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n  _createClass(BufferPool, [{\n    key: \"append\",\n    /** Adds a buffer to the internal buffer pool list */value: function append(buffer) {\n      this.buffers.push(buffer);\n      this.totalByteLength += buffer.length;\n    }\n    /**\n     * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n     * otherwise return null. Size can be negative, caller should error check.\n     */\n  }, {\n    key: \"getInt32\",\n    value: function getInt32() {\n      if (this.totalByteLength < 4) {\n        return null;\n      }\n      var firstBuffer = this.buffers.first();\n      if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n        return firstBuffer.readInt32LE(0);\n      }\n      // Unlikely case: an int32 is split across buffers.\n      // Use read and put the returned buffer back on top\n      var top4Bytes = this.read(4);\n      var value = top4Bytes.readInt32LE(0);\n      // Put it back.\n      this.totalByteLength += 4;\n      this.buffers.unshift(top4Bytes);\n      return value;\n    } /** Reads the requested number of bytes, optionally consuming them */\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      if (typeof size !== 'number' || size < 0) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n      }\n      // oversized request returns empty buffer\n      if (size > this.totalByteLength) {\n        return Buffer.alloc(0);\n      }\n      // We know we have enough, we just don't know how it is spread across chunks\n      // TODO(NODE-4732): alloc API should change based on raw option\n      var result = Buffer.allocUnsafe(size);\n      for (var bytesRead = 0; bytesRead < size;) {\n        var buffer = this.buffers.shift();\n        if (buffer == null) {\n          break;\n        }\n        var bytesRemaining = size - bytesRead;\n        var bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n        var bytes = buffer.subarray(0, bytesReadable);\n        result.set(bytes, bytesRead);\n        bytesRead += bytesReadable;\n        this.totalByteLength -= bytesReadable;\n        if (bytesReadable < buffer.byteLength) {\n          this.buffers.unshift(buffer.subarray(bytesReadable));\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.totalByteLength;\n    }\n  }]);\n  return BufferPool;\n}();\nexports.BufferPool = BufferPool;\n/** @public */\nvar HostAddress = /*#__PURE__*/function () {\n  function HostAddress(hostString) {\n    _classCallCheck(this, HostAddress);\n    this.host = undefined;\n    this.port = undefined;\n    this.socketPath = undefined;\n    this.isIPv6 = false;\n    var escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n    var urlString = \"iLoveJS://\".concat(escapedHost);\n    var url;\n    try {\n      url = new url_1.URL(urlString);\n    } catch (urlError) {\n      var runtimeError = new error_1.MongoRuntimeError(\"Unable to parse \".concat(escapedHost, \" with URL\"));\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n    var hostname = url.hostname;\n    var port = url.port;\n    var normalized = decodeURIComponent(hostname).toLowerCase();\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n    this.host = normalized.toLowerCase();\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n    if (this.port === 0) {\n      throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n    }\n    Object.freeze(this);\n  }\n  _createClass(HostAddress, [{\n    key: Symbol.for('nodejs.util.inspect.custom'),\n    value: function value() {\n      return this.inspect();\n    }\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return \"new HostAddress('\".concat(this.toString(), \"')\");\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (typeof this.host === 'string') {\n        if (this.isIPv6) {\n          return \"[\".concat(this.host, \"]:\").concat(this.port);\n        }\n        return \"\".concat(this.host, \":\").concat(this.port);\n      }\n      return \"\".concat(this.socketPath);\n    }\n  }, {\n    key: \"toHostPort\",\n    value: function toHostPort() {\n      if (this.socketPath) {\n        return {\n          host: this.socketPath,\n          port: 0\n        };\n      }\n      var host = this.host ?? '';\n      var port = this.port ?? 0;\n      return {\n        host: host,\n        port: port\n      };\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(s) {\n      return new HostAddress(s);\n    }\n  }, {\n    key: \"fromHostPort\",\n    value: function fromHostPort(host, port) {\n      if (host.includes(':')) {\n        host = \"[\".concat(host, \"]\"); // IPv6 address\n      }\n\n      return HostAddress.fromString(\"\".concat(host, \":\").concat(port));\n    }\n  }, {\n    key: \"fromSrvRecord\",\n    value: function fromSrvRecord(_ref) {\n      var name = _ref.name,\n        port = _ref.port;\n      return HostAddress.fromHostPort(name, port);\n    }\n  }]);\n  return HostAddress;\n}();\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk: function createPk() {\n    return new bson_1.ObjectId();\n  }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\nexports.emitWarning = emitWarning;\nvar emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n  return false;\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\nfunction shuffle(sequence) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var items = Array.from(sequence); // shallow copy in order to never shuffle the input\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n  var remainingItemsToShuffle = items.length;\n  var lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    var randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1;\n    // And swap it with the current element\n    var swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\nexports.shuffle = shuffle;\n// TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n  return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n  if (oid1 == null) {\n    return -1;\n  }\n  if (oid2 == null) {\n    return 1;\n  }\n  return exports.ByteUtils.compare(oid1.id, oid2.id);\n}\nexports.compareObjectId = compareObjectId;\nfunction parseInteger(value) {\n  if (typeof value === 'number') return Math.trunc(value);\n  var parsedValue = Number.parseInt(String(value), 10);\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\nexports.parseInteger = parseInteger;\nfunction parseUnsignedInteger(value) {\n  var parsedInt = parseInteger(value);\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\nexports.parseUnsignedInteger = parseUnsignedInteger;\n/**\n * Determines whether a provided address matches the provided parent domain.\n *\n * If a DNS server were to become compromised SRV records would still need to\n * advertise addresses that are under the same domain as the srvHost.\n *\n * @param address - The address to check against a domain\n * @param srvHost - The domain to check the provided address against\n * @returns Whether the provided address matches the parent domain\n */\nfunction matchesParentDomain(address, srvHost) {\n  // Remove trailing dot if exists on either the resolved address or the srv hostname\n  var normalizedAddress = address.endsWith('.') ? address.slice(0, address.length - 1) : address;\n  var normalizedSrvHost = srvHost.endsWith('.') ? srvHost.slice(0, srvHost.length - 1) : srvHost;\n  var allCharacterBeforeFirstDot = /^.*?\\./;\n  // Remove all characters before first dot\n  // Add leading dot back to string so\n  //   an srvHostDomain = '.trusted.site'\n  //   will not satisfy an addressDomain that endsWith '.fake-trusted.site'\n  var addressDomain = \".\".concat(normalizedAddress.replace(allCharacterBeforeFirstDot, ''));\n  var srvHostDomain = \".\".concat(normalizedSrvHost.replace(allCharacterBeforeFirstDot, ''));\n  return addressDomain.endsWith(srvHostDomain);\n}\nexports.matchesParentDomain = matchesParentDomain;\nfunction request(_x) {\n  return _request.apply(this, arguments);\n}\nfunction _request() {\n  _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uri) {\n    var options,\n      _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n            return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var requestOptions = _objectSpread({\n                method: 'GET',\n                timeout: 10000,\n                json: true\n              }, url.parse(uri), options);\n              var req = http.request(requestOptions, function (res) {\n                res.setEncoding('utf8');\n                var data = '';\n                res.on('data', function (d) {\n                  data += d;\n                });\n                res.once('end', function () {\n                  if (options.json === false) {\n                    resolve(data);\n                    return;\n                  }\n                  try {\n                    var parsed = JSON.parse(data);\n                    resolve(parsed);\n                  } catch (_unused) {\n                    // TODO(NODE-3483)\n                    reject(new error_1.MongoRuntimeError(\"Invalid JSON response: \\\"\".concat(data, \"\\\"\")));\n                  }\n                });\n              });\n              req.once('timeout', function () {\n                return req.destroy(new error_1.MongoNetworkTimeoutError(\"Network request to \".concat(uri, \" timed out after \").concat(options.timeout, \" ms\")));\n              });\n              req.once('error', function (error) {\n                return reject(error);\n              });\n              req.end();\n            }));\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _request.apply(this, arguments);\n}\nexports.request = request;\n/**\n * A custom AbortController that aborts after a specified timeout.\n *\n * If `timeout` is undefined or \\<=0, the abort controller never aborts.\n *\n * This class provides two benefits over the built-in AbortSignal.timeout() method.\n * - This class provides a mechanism for cancelling the timeout\n * - This class supports infinite timeouts by interpreting a timeout of 0 as infinite.  This is\n *    consistent with existing timeout options in the Node driver (serverSelectionTimeoutMS, for example).\n * @internal\n */\nvar TimeoutController = /*#__PURE__*/function (_AbortController) {\n  _inherits(TimeoutController, _AbortController);\n  function TimeoutController() {\n    var _this3 = this;\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var timeoutId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : timeout > 0 ? (0, timers_1.setTimeout)(function () {\n      return _this2.abort();\n    }, timeout) : null;\n    return function () {\n      var _this2;\n      _classCallCheck(_this3, TimeoutController);\n      _this2 = _possibleConstructorReturn(_this3, _getPrototypeOf(TimeoutController).call(_this3));\n      _this2.timeoutId = timeoutId;\n      return _this2;\n    }();\n  }\n  _createClass(TimeoutController, [{\n    key: \"clear\",\n    value: function clear() {\n      if (this.timeoutId != null) {\n        (0, timers_1.clearTimeout)(this.timeoutId);\n      }\n      this.timeoutId = null;\n    }\n  }]);\n  return TimeoutController;\n}(_wrapNativeSuper(AbortController));\nexports.TimeoutController = TimeoutController;\n/** @internal */\nexports.DOCUMENT_DB_CHECK = /(\\.docdb\\.amazonaws\\.com$)|(\\.docdb-elastic\\.amazonaws\\.com$)/;\n/** @internal */\nexports.COSMOS_DB_CHECK = /\\.cosmos\\.azure\\.com$/;\n/** @internal */\nexports.DOCUMENT_DB_MSG = 'You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb';\n/** @internal */\nexports.COSMOS_DB_MSG = 'You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb';\n/** @internal */\nfunction isHostMatch(match, host) {\n  return host && match.test(host.toLowerCase()) ? true : false;\n}\nexports.isHostMatch = isHostMatch;","map":null,"metadata":{},"sourceType":"script"}